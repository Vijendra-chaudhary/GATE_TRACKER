package com.gate.tracker.ui.subject

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.StickyNote2
import androidx.compose.material3.*
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.SideEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalView
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.core.view.WindowCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import com.gate.tracker.data.local.entity.ChapterEntity
import com.gate.tracker.ui.components.ChapterItem
import com.gate.tracker.ui.components.CelebrationOverlay
import com.gate.tracker.ui.components.CelebrationBanner
import com.gate.tracker.ui.components.ChapterNoteBottomSheet
import com.gate.tracker.ui.subject.ChapterFilter
import com.gate.tracker.ui.resources.ResourcesContent
import com.gate.tracker.ui.resources.ResourcesViewModel
import com.gate.tracker.ResourcesViewModelFactory
import com.gate.tracker.data.repository.GateRepository

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SubjectDetailScreen(
    subjectId: Int,
    viewModel: SubjectDetailViewModel,
    repository: GateRepository,
    onBackClick: () -> Unit
) {
    val subject by viewModel.subject.collectAsState()
    val chapters by viewModel.chapters.collectAsState()
    val chapterNotes by viewModel.chapterNotes.collectAsState()
    val currentFilter by viewModel.currentFilter.collectAsState()
    
    // Tab state
    var selectedTab by remember { mutableStateOf(0) }
    
    // Resources ViewModel
    val resourcesViewModel: ResourcesViewModel = viewModel(
        factory = ResourcesViewModelFactory(repository, subjectId)
    )
    
    // Celebration states
    var showCelebration by remember { mutableStateOf(false) }  // Subject completion
    var showChapterBanner by remember { mutableStateOf(false) }  // Chapter completion
    
    // Note bottom sheet state
    var selectedChapterForNote by remember { mutableStateOf<ChapterEntity?>(null) }
    var showNoteBottomSheet by remember { mutableStateOf(false) }
    
    // Track previous completed count
    val previousCompletedRef = remember { mutableStateOf<Int?>(null) }
    
    LaunchedEffect(subjectId) {
        viewModel.loadSubject(subjectId)
    }
    
    // Monitor subject completion changes
    LaunchedEffect(subject) {
        subject?.let { subj ->
            val currentCompleted = subj.completedChapters
            val totalChapters = subj.totalChapters
            val previousCompleted = previousCompletedRef.value
            
            android.util.Log.d("CELEBRATION", "Subject: ${subj.name}, Current: $currentCompleted, Total: $totalChapters, Previous: $previousCompleted")
            
            // Celebration triggers when:
            // - We have a previous count (not first load)
            // - Subject just hit 100% (current == total)
            // - It wasn't 100% before (previous != total)
            if (previousCompleted != null && 
                previousCompleted != totalChapters &&
                currentCompleted == totalChapters &&
                totalChapters > 0) {
                android.util.Log.d("CELEBRATION", "ðŸŽ‰ TRIGGERING CELEBRATION!")
                showCelebration = true
            }
            
            // Update previous count
            previousCompletedRef.value = currentCompleted
        }
    }
    
    // Calculate progress
    val targetProgress = subject?.let {
        if (it.totalChapters > 0) {
            it.completedChapters.toFloat() / it.totalChapters.toFloat()
        } else 0f
    } ?: 0f
    
    // Animate progress for smooth transitions
    val animatedProgress by animateFloatAsState(
        targetValue = targetProgress,
        animationSpec = tween(
            durationMillis = 400,
            easing = FastOutSlowInEasing
        ),
        label = "progress"
    )
    
    // Match status bar color
    val view = LocalView.current
    val primaryContainer = MaterialTheme.colorScheme.primaryContainer
    SideEffect {
        val window = (view.context as? android.app.Activity)?.window ?: return@SideEffect
        window.statusBarColor = primaryContainer.hashCode()
        WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = true
    }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(MaterialTheme.colorScheme.background)
    ) {
        // Modern App Bar
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .background(MaterialTheme.colorScheme.primaryContainer)
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 16.dp)
                    .statusBarsPadding(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                IconButton(onClick = onBackClick) {
                    Icon(
                        imageVector = Icons.Default.ArrowBack,
                        contentDescription = "Back",
                        tint = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                }
                Spacer(modifier = Modifier.width(8.dp))
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = subject?.name ?: "",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                    subject?.let {
                        Text(
                            text = "${it.completedChapters} / ${it.totalChapters} chapters",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.7f)
                        )
                    }
                }
            }
        }
        
        // Tabs
        TabRow(
            selectedTabIndex = selectedTab,
            containerColor = MaterialTheme.colorScheme.background
        ) {
            Tab(
                selected = selectedTab == 0,
                onClick = { selectedTab = 0 },
                text = { Text("Chapters") }
            )
            Tab(
                selected = selectedTab == 1,
                onClick = { selectedTab = 1 },
                text = { Text("Resources") }
            )
        }
        
        // Tab Content
        when (selectedTab) {
            0 -> ChaptersTabContent(
                subject = subject,
                chapters = chapters,
                chapterNotes = chapterNotes,
                currentFilter = currentFilter,
                animatedProgress = animatedProgress,
                onFilterChange = { viewModel.setFilter(it) },
                onNoteClick = { chapter ->
                    selectedChapterForNote = chapter
                    showNoteBottomSheet = true
                },
                onToggleChapter = { chapter ->
                    // Show banner for individual chapter completion (not last chapter)
                    if (!chapter.isCompleted) {
                        val willComplete = subject?.let { it.completedChapters + 1 == it.totalChapters } ?: false
                        if (!willComplete) {
                            showChapterBanner = true
                        }
                    }
                    viewModel.toggleChapter(chapter)
                }
            )
            1 -> ResourcesContent(
                viewModel = resourcesViewModel
            )
        }
            modifier = Modifier.fillMaxSize(),
            contentPadding = PaddingValues(vertical = 8.dp)
        ) {
            // Progress indicator card
            item {
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp, vertical = 8.dp),
                    shape = RoundedCornerShape(16.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.primaryContainer
                    )
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(20.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Text(
                                text = "Progress",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.onPrimaryContainer
                            )
                            Text(
                                text = "${(animatedProgress * 100).toInt()}%",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.primary
                            )
                        }
                        
                        LinearProgressIndicator(
                            progress = animatedProgress,
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(8.dp),
                            color = MaterialTheme.colorScheme.primary,
                            trackColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.2f)
                        )
                    }
                }
            }
            
            // Filter chips row 1 - Completion Status
            item {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp, vertical = 8.dp),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    FilterChip(
                        selected = currentFilter == ChapterFilter.ALL,
                        onClick = { viewModel.setFilter(ChapterFilter.ALL) },
                        label = { Text("All") }
                    )
                    FilterChip(
                        selected = currentFilter == ChapterFilter.PENDING,
                        onClick = { viewModel.setFilter(ChapterFilter.PENDING) },
                        label = { Text("â—‹ Pending") }
                    )
                    FilterChip(
                        selected = currentFilter == ChapterFilter.COMPLETED,
                        onClick = { viewModel.setFilter(ChapterFilter.COMPLETED) },
                        label = { Text("âœ“ Done") }
                    )
                }
            }
            
            // Filter chips row 2 - Chapter Attributes
            item {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp)
                        .padding(bottom = 8.dp),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    FilterChip(
                        selected = currentFilter == ChapterFilter.IMPORTANT,
                        onClick = { viewModel.setFilter(ChapterFilter.IMPORTANT) },
                        label = { Text("â­ Important") }
                    )
                    FilterChip(
                        selected = currentFilter == ChapterFilter.NEEDS_REVISION,
                        onClick = { viewModel.setFilter(ChapterFilter.NEEDS_REVISION) },
                        label = { Text("ðŸ”„ Revision") }
                    )
                    FilterChip(
                        selected = currentFilter == ChapterFilter.WITH_NOTES,
                        onClick = { viewModel.setFilter(ChapterFilter.WITH_NOTES) },
                        label = { Text("ðŸ“ Notes") }
                    )
                }
            }
            
            // Filter chapters based on selected filter
            val filteredChapters = chapters.filter { chapter ->
                val note = chapterNotes[chapter.id]
                when (currentFilter) {
                    ChapterFilter.ALL -> true
                    ChapterFilter.IMPORTANT -> note?.isImportant == true
                    ChapterFilter.NEEDS_REVISION -> note?.needsRevision == true
                    ChapterFilter.WITH_NOTES -> note != null
                    ChapterFilter.COMPLETED -> chapter.isCompleted
                    ChapterFilter.PENDING -> !chapter.isCompleted
                }
            }
            
            // Chapters grouped by category
            val chaptersWithCategory = filteredChapters.filter { it.category != null }
            val chaptersWithoutCategory = filteredChapters.filter { it.category == null }
            val categories = chaptersWithCategory
                .groupBy { it.category }
                .keys
                .sortedBy { category ->
                    chaptersWithCategory.indexOfFirst { it.category == category }
                }
            
            // Show categorized chapters
            if (categories.isNotEmpty()) {
                categories.forEach { category ->
                    val categoryChapters = filteredChapters.filter { it.category == category }
                    val completedInCategory = categoryChapters.count { it.isCompleted }
                    
                    // Category header
                    item(key = "category_$category") {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = 16.dp, vertical = 12.dp),
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Text(
                                text = category ?: "",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.primary
                            )
                            Text(
                                text = "$completedInCategory/${categoryChapters.size}",
                                style = MaterialTheme.typography.titleSmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                    
                    // Chapters in category
                    items(categoryChapters, key = { it.id }) { chapter ->
                        val note = chapterNotes[chapter.id]
                        ChapterItem(
                            chapter = chapter,
                            hasNote = note != null,
                            hasNoteText = note?.noteText?.isNotBlank() ?: false,
                            isImportant = note?.isImportant ?: false,
                            needsRevision = note?.needsRevision ?: false,
                            onNoteClick = {
                                selectedChapterForNote = chapter
                                showNoteBottomSheet = true
                            },
                            onToggle = {
                                // Show banner for individual chapter completion (not last chapter)
                                if (!chapter.isCompleted) {
                                    val willComplete = subject?.let { it.completedChapters + 1 == it.totalChapters } ?: false
                                    if (!willComplete) {
                                        showChapterBanner = true
                                    }
                                }
                                viewModel.toggleChapter(chapter)
                            }
                        )
                    }
                }
            }
            
            // Show uncategorized chapters (if any)
            if (chaptersWithoutCategory.isNotEmpty()) {
                item(key = "uncategorized_header") {
                    Text(
                        text = if (categories.isEmpty()) "Chapters" else "Other Chapters",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onBackground, // Fixed dark mode visibility
                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 12.dp)
                    )
                }
                
                items(chaptersWithoutCategory, key = { it.id }) { chapter ->
                    val note = chapterNotes[chapter.id]
                    ChapterItem(
                        chapter = chapter,
                        hasNote = note != null,
                        hasNoteText = note?.noteText?.isNotBlank() ?: false,
                        isImportant = note?.isImportant ?: false,
                        needsRevision = note?.needsRevision ?: false,
                        onNoteClick = {
                            selectedChapterForNote = chapter
                            showNoteBottomSheet = true
                        },
                        onToggle = {
                            // Show banner for individual chapter completion (not last chapter)
                            if (!chapter.isCompleted) {
                                val willComplete = subject?.let { it.completedChapters + 1 == it.totalChapters } ?: false
                                if (!willComplete) {
                                    showChapterBanner = true
                                }
                            }
                            viewModel.toggleChapter(chapter)
                        }
                    )
                }
            }
            
            // Bottom spacing
            item {
                Spacer(modifier = Modifier.height(80.dp))
            }
        }
    }
    
    // Full-screen celebration overlay for subject completion
    if (showCelebration) {
        CelebrationOverlay(
            onDismiss = { showCelebration = false }
        )
    }
    
    // Chapter completion banner (for non-final chapters)
    if (showChapterBanner) {
        CelebrationBanner(
            message = "Chapter Completed!",
            onDismiss = { showChapterBanner = false }
        )
    }
    
    // Chapter note bottom sheet
    if (showNoteBottomSheet && selectedChapterForNote != null) {
        val note = chapterNotes[selectedChapterForNote!!.id]
        ChapterNoteBottomSheet(
            chapterName = selectedChapterForNote!!.name,
            existingNote = note?.noteText,
            isImportant = note?.isImportant ?: false,
            needsRevision = note?.needsRevision ?: false,
            onDismiss = {
                showNoteBottomSheet = false
                selectedChapterForNote = null
            },
            onSave = { noteText, isImportant, needsRevision ->
                viewModel.saveNote(
                    chapterId = selectedChapterForNote!!.id,
                    noteText = noteText,
                    isImportant = isImportant,
                    needsRevision = needsRevision
                )
            },
            onDelete = if (note != null) {
                { 
                    viewModel.deleteNote(selectedChapterForNote!!.id)
                    showNoteBottomSheet = false
                    selectedChapterForNote = null
                }
            } else null
        )
    }
}
